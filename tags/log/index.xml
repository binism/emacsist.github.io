<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>log on emacsist</title>
    <link>https://emacsist.github.io/tags/log/</link>
    <description>Recent content in log on emacsist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 02 Mar 2017 13:46:21 +0000</lastBuildDate>
    
	<atom:link href="https://emacsist.github.io/tags/log/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>https.protocols在Java中的使用</title>
      <link>https://emacsist.github.io/2017/03/02/https.protocols%E5%9C%A8java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 02 Mar 2017 13:46:21 +0000</pubDate>
      
      <guid>https://emacsist.github.io/2017/03/02/https.protocols%E5%9C%A8java%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>Caused by: java.io.EOFException: SSL peer shut down incorrectly 在服务器上，发现一个微博爬虫系统偶尔会报这种异常。Google 了下，在 Stackoverflow 上看到相关的回答。所以决定详细了解下这原理。 上面说，</description>
    </item>
    
    <item>
      <title>Java 一次启动失败分析案例</title>
      <link>https://emacsist.github.io/2017/02/09/java-%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Thu, 09 Feb 2017 11:32:22 +0000</pubDate>
      
      <guid>https://emacsist.github.io/2017/02/09/java-%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</guid>
      <description>今天，在部署外网的测试环境时，发现启动时报如下错误： Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c6d80000, 42991616, 0) failed; error=&#39;Cannot allocate memory&#39; (errno=12) # # There is insufficient memory for the Java Runtime Environment to continue. # Native memory allocation (malloc) failed to allocate 42991616 bytes for committing reserved memory. # An</description>
    </item>
    
    <item>
      <title>Tomcat 8 源码学习五之Tomcat日志系统</title>
      <link>https://emacsist.github.io/2016/06/29/tomcat-8-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%BA%94%E4%B9%8Btomcat%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 29 Jun 2016 11:06:13 +0000</pubDate>
      
      <guid>https://emacsist.github.io/2016/06/29/tomcat-8-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%BA%94%E4%B9%8Btomcat%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid>
      <description>juli 默认情况下，Tomcat使用自身的juli作为Tomcat内部的日志处理系统.它的源码，在Tomcat源码结构下的org.apache.j</description>
    </item>
    
    <item>
      <title>Bash处理日志文件脚本</title>
      <link>https://emacsist.github.io/2016/02/22/bash%E5%A4%84%E7%90%86%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Mon, 22 Feb 2016 18:11:05 +0000</pubDate>
      
      <guid>https://emacsist.github.io/2016/02/22/bash%E5%A4%84%E7%90%86%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC/</guid>
      <description>因为公司需要一个处理日志并迁移到指定服务器的脚本，所以就写了以下这个，虽然比较简陋，但还是可以使用的&amp;hellip; 思路: 从指定的目录数组中</description>
    </item>
    
    <item>
      <title>Java 日志实践</title>
      <link>https://emacsist.github.io/2015/07/23/java-%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Thu, 23 Jul 2015 14:12:17 +0000</pubDate>
      
      <guid>https://emacsist.github.io/2015/07/23/java-%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/</guid>
      <description>每个类一个Logger private static final Logger LOG = LoggerFactory.getLogger(Your.class); 日志级别 trace 最详细的日志级别信息 debug 调试级别的日志级别信息 info 一般的日志级别信息 warn 警告级别信息 error 错误级别信息 fatal</description>
    </item>
    
  </channel>
</rss>